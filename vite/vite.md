# 为什么选择 vite

在es 模块之前，主要通过script标签请求，来将脚本进行串联起来。
通俗的理解 `bundling`:使用工具请求，处理源代码模块，将其串联为可在浏览器中运行的文件。

随着应用程序变得越来越庞大，我们开始遇到工具的性能瓶颈。例如：文件的编辑可能需要花费几秒钟的时间
才会响应到浏览器中。

vite 利用浏览器中本地es 模块的可用性，以及以编译为本地语言编写的javascript 工具的兴起，来解决工具的性能问题。


## 服务启动缓慢
冷启动开发服务器时，必须急切地获取所有模块并构建整个应用程序，然后才能提供服务。

vite 将应用程序的模块分成了两类：依赖项和源代码，从而缩短了开发服务器的启动时间。
- 依赖项大多是普通的javascript，在开发过程中不会经常变化。
  
  vite 使用esbuild 预先捆绑以来关系。esbuild 由go语言编写，其预先捆绑速度比基于javascript 的捆绑程序快10-100倍。

- 源码通常需要进行转换，而且会经常被编辑。另外，并非所有源代码都需要同时加载。

  vite 通过本地esm 提供源代码。实质上是让浏览器接管了捆绑程序的部分工作：vite 只需要
  根据浏览器的要求转换和提供源代码。有条件的动态导入后面的代码只有在当前屏幕上实际使用时才会被处理。

## 慢更新
在基于捆绑程序的构建设置中编辑文件时，重建整个捆绑程序的效率很低。更新速度会随着应用程序的变大而下降。


在某些捆绑程序中，开发服务器在内存中运行捆绑，因此当文件发生变化时，它只需要是模块的一部分失效，
但是任需要重新构建整个捆绑程序并重新加载网页。重新构建捆绑包的成本很高，而且重新加载网页会破坏应用程序的
当前状态。这就是为什么有些捆绑程序支持热模块替换，允许模块替换自身而不影响页面的其他部分。但是随着程序的扩大
，HMR更新速度也会明显下降。

在vite 中，HMR 通过本地ESM 执行。编辑文件时，vite 只需精确的使已编辑模块与其最接近的HMR边界之间的链失效。
从而使HMR 更新始终保持快速，无论应用程序的大小如何。



尽管 ESM 现在已经得到了广泛的支持，但由于嵌套导入会导致额外的网络往返，因此想在生产中获得最佳加载性能，因此可以结合
tree-shaking、lazy-loading、chunk-splitting




vite 插件API 与esbuild 不兼容。但是vite 可以采用rollup 的插件API和基础架构。
就目前而言，rollup 在性能和灵活性之间能做出更好的权衡。










